#!/bin/bash

# Die Skripte 

# Die Werte in "bunchverteilung_leerzeichen.txt" sind durch ein Leerzeichen getrennt.
# Ausgabe als ASCII- und als Binärdatei. Erstere kann mit einem Texteditor betrachtet werden, letztere ist für schnelles Rechnen besser geeignet (nötig für Pelegant (=parallel elegant)) und nimmt auch weniger Speicherplatz ein.
# Die Option "-noRowCount" ist nötig, wenn in der ersten Zeile nicht stehen sollte, wie viele Zeilen die Datei beinhaltet (eigentlich Standard).
plaindata2sdds bunchverteilung_leerzeichen.txt bunchverteilung_leerzeichen.ascii.sdds  -inputMode=ascii -col=t,double,units=s -col=x,double,units=m -col=xp,double -col=y,double,units=m -col=yp,double -col=p,double,units='m$be$nc' -noRowCount -outputMode=ascii
plaindata2sdds bunchverteilung_leerzeichen.txt bunchverteilung_leerzeichen.binary.sdds -inputMode=ascii -col=t,double,units=s -col=x,double,units=m -col=xp,double -col=y,double,units=m -col=yp,double -col=p,double,units='m$be$nc' -noRowCount -outputMode=binary
# Bei der Verwendung von "plaindata2sdds" muss man angeben, ob der Input ASCII oder binär ist.



# Die Werte in "bunchverteilung_komma.txt" sind durch ein Komma getrennt.
# Alternativ kann man auch über die Option "-separator=character" ein anderes Trennzeichen angegeben.
# In "bunchverteilung_komma.txt" liegt auch eine andere Reihenfolge als in "bunchverteilung_leerzeichen.txt" vor! Daher bei der Reihenfolge der "-col=..." aufpassen!
# statt der Kurzform "-col=..." hier exemplarisch mal die Langform "-column=name=...,type=double" verwendet.
csv2sdds bunchverteilung_koma.csv bunchverteilung_koma.binary.sdds -column=name=t,type=double,units=s -column=name=p,type=double,units='m$be$nc' -column=name=x,type=double,units=m -column=name=xp,type=double -column=name=y,type=double,units=m -column=name=yp,type=double -skiplines=1
# "csv2sdds" erwartet immer ASCII als Input und gibt standardmäßig binär als Output. Um ASCII als Output zu erhalten gibt es die Option "-asciiOutput". Die Syntax ist bei "csv2sdds" also etwas anders als bei "plaindata2sdds".
csv2sdds bunchverteilung_koma.csv bunchverteilung_koma.ascii.sdds  -column=name=t,type=double,units=s -column=name=p,type=double,units='m$be$nc' -column=name=x,type=double,units=m -column=name=xp,type=double -column=name=y,type=double,units=m -column=name=yp,type=double -skiplines=1 -asciiOutput
# Der Größe Vorteil von "csv2sdds" gegenüber "plaindata2sdds" ist, dass es die Option "-skiplines=integer" gibt und somit eine definierte Anzahl an Zeilen (beginnend bei der ersten) ignoriert werden können. Somit müssen Header-Zeilen vorher nicht gelöscht werden.

# Hinweis: Die Einheit von p ist m_{0,e}*c, in SDDS formatiert ist das m$be$nc.
# In den Befehlen oben gelingt es (mir) nicht, m$be$nc korrekt zu übergeben. Nutzt man 'm$be$nc', so erscheint "m$be$nc" in der SDDS-Datei.
# Bei einem ersten Test konnte ich keine Probleme feststellen, außer das beim Plot der Initaldatei die Einheit nicht schön dargestellt wird.
# elegant rechnet aber korrekt mit der Größe p und in den späteren Ergebnissen resultiert korrekt m$be$nc.
# Wer weiß, wie man m$be$nc ordentlich per Skript übergibt, möge es mir bitte mitteilen ( fschliessmann@ikp.tu-darmstadt.de ).
# Etwas umständlich gelingt es, wenn man die fragliche Datei mit einem SDDS-Editor öffnet, die Spalte p anwählt und dann über Edit/Column/Attributes... bei "units:" händisch m$be$nc einträgt und dann über File/Save die Datei überschreibt.
# Alternativ kann man auch mit einem Skript (z.B. in Python) die Datei öffnen, die Zeile 
#	&column name=p, units="m$be$nc", type=double,  &end
# suchen und "m$be$nc" durch m$be$nc ersetzen und die Datei abspeichern. Bei einer ASCII-Datei ist das kein Problem. Bei einer Binärdatei ist es im Allgemeinen unklar. Ein erster Test hat keine Fehler vorgezeigt, da aber unklar ist, ob es wirklich keine Fehler erzeugt, wird es hier vorerst nicht empfohlen und daher auch kein solches Skript zur Verfügung gestellt.

# Im elegant Manual selbst steht:
#		elegant: (x, xp, y, yp, t, p), where x and y are in meters, xp = x′ and xp = y′ are dimensionless,
#		t is in seconds, and p = fifl is the dimensionless momentum. If this file is to be
#		generated by the user, the expected units string in the column definitions should be “m”,
#		“s”, and “m$be$nc” for meters, seconds and the dimensionless momentum, respectively.
#		The particleID column may also be given; it should contain a positive integer that is
#		unique for each particle.

# Es kann auch sein, dass die Programmierer von elegant sich der Problematik bei p und m$be$nc bewusst sind und die übergebene Einheit von p ignorieren und intern m$be$nc als Standard setzen. Dazu müsste man mal in den Source-Code gucken.
# Ein beliebiger Wert führt zu auf den ersten Blick korrekt ausgeführten Simulationen.
# Bei x, xp, y, yp und t hingegen ist elegant streng. Stimmt die Einheit nicht, verweigert elegant die Simulation:
#	necessary data quantities (x, x', y, y', t, p) have the wrong units or are not present in ./bunch.sdds
# Taucht die Variable x, xp, y, yp und/oder t nicht auf, erscheint ebenfalls
#	necessary data quantities (x, x', y, y', t, p) have the wrong units or are not present in ./bunch.sdds
# Taucht hingegen die Variable p nicht auf, erscheint
#	Unable to process column selection--unrecognized column name p seen (SDDS_SetColumnsOfInterest)
#	Problem setting columns of interest for file ./bunch.sdds

# Die erzeugten Bunch-Verteilungen im SDDS-Format können jetzt in einer *.ele-Datei eingelesen werden.
# Statt dem Block "&bunched_beam" wird der Block "&sdds_beam" verwendet:
#	&sdds_beam    
#		input=./individuelle_bunch_verteilung.sdds ! zu importierende Bunch-Verteilung in einer SDDS-formatierten Datei (ASCII- oder Binärdatei).
#		reuse_bunch=1 ! Falls man mehrere Bunch-Verteilungen hat, kann man diese auch in einer SDDS-Datei auf mehreren Seiten speichern. In diesem Fall werden also mehrere Trackings durchgeführt, eins pro Bunch-Verteilung, d.h. so viele Trackings wie Seiten in der SDDS-Datei. Mit "reuse_bunch=1" wird das ausgehebelt. Details siehe elegant Manual.
#	&end